'''
Created on Mar 29, 2012

@author: Steven
'''
import sqlalchemy
import sqlalchemy.orm
from sqlalchemy.sql import select
#from scipy import stats
import numpy

import Inventory

class ShoppingListItem (object):
    
    def __init__(self, listId, name, creationDate, autoGeneratedFlag):
        self.listId = listId
        self.name = name
        self.creationDate = creationDate
        self.autoGeneratedFlag = autoGeneratedFlag
        self.identifier = None
        
    def __repr__(self):
        return "<ShoppingList(%d, %s)" % (self.listId, self.name)
    
class ShoppingListLinkerItem (object):
    
    def __init__(self, listId, itemId, itemDescription, quantity):
        self.listId = listId
        self.itemId = itemId
        self.itemDescription = itemDescription
        self.quantity = quantity
        self.identifier = None
        
    def __repr__(self):
        return "<Linker(%d, %d, %d)>" % (self.listId, self.itemId, self.quantity)

class ShoppingListTable (object):
    '''
    classdocs
    '''

    def __init__(self, model):
        '''
        Constructor
        '''
        self.model = model
        
        shoppingListTable = sqlalchemy.Table('shoppingList', self.model.metadata, \
            sqlalchemy.Column('id', sqlalchemy.Integer, primary_key=True), \
            sqlalchemy.Column('listId', sqlalchemy.Integer, primary_key=True), \
            sqlalchemy.Column('name', sqlalchemy.String(128)), \
            sqlalchemy.Column('creationDate', sqlalchemy.DateTime), \
            sqlalchemy.Column('autoGeneratedFlag', sqlalchemy.Boolean), \
            sqlalchemy.Column('identifier', sqlalchemy.String(16)))
        
        shoppingListLinkerTable = sqlalchemy.Table('shoppingListLinker', self.model.metadata, \
            sqlalchemy.Column('id', sqlalchemy.Integer, primary_key=True), \
            sqlalchemy.Column('listId', sqlalchemy.Integer, primary_key=True), \
            sqlalchemy.Column('itemId', sqlalchemy.BigInteger), \
            sqlalchemy.Column('itemDescription', sqlalchemy.String(128)), \
            sqlalchemy.Column('quantity', sqlalchemy.Integer), \
            sqlalchemy.Column('identifier', sqlalchemy.String(44)))
        
        self.model.metadata.create_all (self.model.engine)
        sqlalchemy.orm.mapper (ShoppingListItem, shoppingListTable)
        sqlalchemy.orm.mapper (ShoppingListLinkerItem, shoppingListLinkerTable)
        
        Session = sqlalchemy.orm.sessionmaker(bind=self.model.engine)
        self.session = Session()
        
        self.listId = 0
        for shoppingList in self.session.query(ShoppingListItem).distinct():
            self.model.controllerObj.addNewShoppingList (shoppingList)
            if self.listId <= shoppingList.listId: 
                self.listId = shoppingList.listId+1 
                
        for linker in self.session.query(ShoppingListLinkerItem).distinct():
            self.model.controllerObj.addNewShoppingListItem (linker)
        
    def addNewShoppingList (self, shoppingList):
        self.session.add(shoppingList)
        self.session.commit()
        
    def returnListByIdentifier (self, identifier):
        return self.session.query(ShoppingListItem).filter(ShoppingListItem.identifier==identifier).all()
    
    def returnListItemByIdentifier (self, identifier):
        return self.session.query(ShoppingListLinkerItem).filter(ShoppingListLinkerItem.identifier==identifier).all()
    
    def returnLinkerItem (self, shoppingList, item):
        return self.session.query(ShoppingListLinkerItem).filter((ShoppingListLinkerItem.listId==shoppingList.listId) & \
            (ShoppingListLinkerItem.itemId==item.upc)).all()
            
    def returnCustomLinkerItem (self, shoppingList, description):
        return self.session.query(ShoppingListLinkerItem).filter((ShoppingListLinkerItem.listId==shoppingList.listId) & \
            (ShoppingListLinkerItem.itemDescription==description)).all()
            
    def addNewShoppingListItem (self, linker):
        self.session.add(linker)
        self.session.commit()
        
    def updateShoppingListItem (self):
        self.session.commit()
        
    def removeShoppingList (self, shoppingList):
        self.session.delete(shoppingList)
       
        items = self.session.query(ShoppingListLinkerItem).filter((ShoppingListLinkerItem.listId==shoppingList.listId)).all() 
        for item in items:
            self.session.delete(item)
        
        self.session.commit()
        
    def removeShoppingListItem (self, shoppingListItem):
        self.session.delete(shoppingListItem)
        self.session.commit()
        
    def grantNewListId (self):
        returnValue = self.listId
        self.listId += 1
        
        return returnValue
    
    def gaussianKde (self, x0, xs):
        if len(xs) == 0:
            return 0.
        else:
            bw = 3. / 4. * len(xs) ** (-.2)
            p = 0.
            
            for lcv in xrange(len(xs)):
                d = x0 - xs[-(lcv+1)]
                p += .3989 * numpy.exp(-.5 * d * d / bw)
                
            wp = p / (len(xs) * bw)
            
            return wp
    
    def populateSuggestedShoppingList (self, shoppingList):
        table = self.model.currentInventory.purchaseHistoryTable
        recommendationThreshold = 0.10
        minItems = 5
        
        allPurchasedItems = self.session.query(table.c.upc).distinct()
        allPurchasedItems = [x[0] for x in allPurchasedItems]
        
        probabilities = []
        for upc in allPurchasedItems:
            purchaseDates = self.session.query(table.c.purchaseDate).filter(Inventory.PurchaseHistoryItem.upc==upc).all()
            purchaseDates = [x[0] for x in purchaseDates]
            purchaseDates = sorted(purchaseDates)
            
            if len(purchaseDates) > 2:
                purchaseDiffs = [(purchaseDates[x] - purchaseDates[x-1]).total_seconds() / (60 * 60) for x in range(1,len(purchaseDates))]
#                kde = stats.kde.gaussian_kde(numpy.array(purchaseDiffs))
                currentTimeDiff = (self.model.timeWrapper.returnTime() - purchaseDates[-1]).total_seconds() / (60 * 60)
                probabilities.append((upc, self.gaussianKde(currentTimeDiff, purchaseDiffs)))
#                probabilities.append((upc,kde(currentTimeDiff)))
                
        probabilities = sorted(probabilities, key = lambda x:x[1])
        recommended = dict()
        recommendedItems = [x for x in probabilities if x[1] > recommendationThreshold]
        
        minItems = numpy.min([len(allPurchasedItems), minItems])
        
        if len(recommendedItems) > minItems:
            recommended['suggested'] = True
            recommended['items'] = [x[0] for x in recommendedItems]
        else:
            recommended['suggested'] = False
            recommended['items'] = [x[0] for x in probabilities[0:minItems]]
            
        return recommended 
#                print 'upc: ' + str(upc) + 'date: ' + str(purchaseDiffs) + ' current: ' + str(currentTimeDiff)
#                print 'prob: ' + str(kde(currentTimeDiff))
            